---
title: "Miscs"
date: 2027-01-14
categories: [Misc]
tags: [Misc]
---

# DNS Lookup Flow (Example)

## Step 1: Browser Request

You type `www.example.com` in your browser.

## Step 2: OS and Resolver

The browser asks your OS, and the OS asks a DNS resolver (e.g., `1.1.1.1`).

## Step 3: Root Servers

Resolver checks cache → miss → asks root servers:  
"Who handles `.com`?"

Root replies: "Ask `.com` TLD servers."

## Step 4: TLD Servers

Resolver asks `.com` TLD servers:  
"Who is authoritative for `example.com`?"

TLD replies: "`example.com` → `ns-123.awsdns-45.net`"

## Step 5: Authoritative Server

Resolver asks the authoritative server:  
"What is `www.example.com`?"

Authoritative server replies: "`www.example.com` → `203.0.113.10`"

## Step 6: Cache and Connect

Resolver caches the answer, returns the IP to the OS → browser connects to `203.0.113.10`.

Connection is established → page loads.

Q. How does SSH works? What happens when you type `ssh user@hostname`?
A.

# Why use K8s

If you are breaking down your app into independent sub components that individually require different 
scaling. Then kubernetes will be a good fit for your app.


## Can any set of IPs be used as private IPs?
- **No.** Only specific ranges are defined as private IPv4 (RFC 1918):
  - `10.0.0.0/8`
  - `172.16.0.0/12`
  - `192.168.0.0/16`
- You *can* use public IP ranges internally, but it’s a bad idea because it causes **routing conflicts** when you need to reach the real public internet owners of those ranges (VPN/peering/partners break easily).
- Other “non-public” but not RFC1918:
  - `100.64.0.0/10` (CGNAT, can conflict depending on environment)
  - `169.254.0.0/16` (link-local)
  - `127.0.0.0/8` (loopback)
  - multicast/reserved ranges (not for private LANs)

## Why not always use /8 inside private networks?
- Using a `/8` as a single flat subnet is usually a bad idea:
  - **ARP/broadcast scaling issues** (hosts may ARP for any 10.x.x.x destination)
  - Huge **failure domain** (storms/loops/misconfigs affect more)
  - Harder **security segmentation** and policy control
  - Messy troubleshooting and IP management
  - Increases chance of **overlap** with other networks (VPNs/partners)
- Best practice:
  - Treat `10.0.0.0/8` as a **large address pool**
  - Subdivide into smaller routed blocks (e.g., /16s for environments, /24s–/21s for subnets)
  - Use summary routes where appropriate

## Should a Kubernetes cluster be inside a private network?
- **Usually yes.**
- Keep **nodes and control-plane access** private, and expose apps through controlled edges:
  - Load balancer / Ingress
  - API gateway / WAF
  - VPN / bastion / zero-trust proxy for admin access
- Public exposure should be for **applications**, not node internals or the Kubernetes API.

## How does a node get an IP address?
Kubernetes nodes get IPs like any other machine:

### 1) DHCP
- Node requests an address from a DHCP server
- Receives IP + mask + gateway + DNS

### 2) Static configuration
- Admin/provisioning sets IP/mask/gateway on the OS

### 3) Cloud assignment (most common for managed k8s)
- VM is attached to a **subnet** in a VPC/VNet
- Cloud assigns a **private IP** to the VM’s NIC (DHCP-like under the hood)
- Public IP is optional and typically avoided for nodes

Kubernetes learns the node IP via:
- **kubelet** auto-detecting it from interfaces/routes (or forced using `--node-ip`)
- Stored as Node `InternalIP`/`ExternalIP` in the API

## In clouds, do they have some DHCP server that manages the subnet?
- **Yes, conceptually.**
- Each subnet has a **provider-managed DHCP service** (not a VM you manage).
- It provides configuration like:
  - IP address assignment
  - Default gateway
  - DNS settings
- Also tightly integrated with the cloud control plane and the NIC object (ENI/NIC).

## Hypervisors: Type 1 vs Type 2

A hypervisor lets multiple OS instances share a host.

- Type 1 (bare metal) runs directly on hardware and controls CPU, memory, and devices.
- Type 2 runs as an app on a host OS, adding extra overhead.

Type 1 hypervisors are standard in data centers and cloud platforms because they are more efficient and offer stronger isolation. This is not the same as dual‑boot; all guests run concurrently.

## OSI Model

OSI model is a conceptual model which is used for understanding purpose, it's not used in the real
world. TCP/IP is the protocol that is used in the real world. We will look into both.

<img src="{{site.baseurl}}/assets/img/osi-model.png">

The mac address seen above is of the next hop device and not the destination device.

Application Layer  - Provides network services to end-user applications (HTTP, FTP, SMTP).
Presentation Layer - Translates, encrypts, and compresses data for proper interpretation.
Session Layer      - Establishes, manages, and terminates communication sessions.
Transport Layer    - Ensures reliable or fast data delivery using TCP/UDP.
Network Layer      - Determines best path using logical addressing (IP).
Data Link Layer    - Handles node-to-node delivery using MAC addresses and framing. Switch works here.
Physical Layer     - Transmits raw bits over cables or wireless signals.

<img src="{{site.baseurl}}/assets/img/tcp-ip-model.png">
